package main

import (
	"bytes"
	"fmt"
	"strings"
)

type Markdown struct {
	Title          string
	MainStructName string
	Desc           string
	ObjTitleFunc   func(modPath string, typeName string) string
}

func (mk *Markdown) Generate(data map[string]StructInfo) []byte {
	buf := bytes.NewBuffer(nil)

	buf.WriteString("# " + mk.Title + "\n")

	types := make([]string, 0)
	tpMap := make(map[string]struct{})
	genStruct := func(structInfo StructInfo) {
		if len(structInfo.Describe) != 0 {
			buf.WriteString(transMarkdownField(structInfo.Describe, true))
			buf.WriteString("\n")
		}

		buf.WriteString(
			"| Key      | Type      | Require | Default           | Describe          |\n" +
				"|----------|----------|-----|------------------|--------------|\n")
		for _, item := range structInfo.Fields {
			buf.WriteString("|")
			buf.WriteString(transMarkdownField(item.Name, false))
			buf.WriteString("|")
			if item.Reference != "" {
				buf.WriteString(fmt.Sprintf("[%s](#%s)", item.Type, mk.ObjTitleFunc(item.Reference, item.Type)))
				key := genKey(item.Reference, item.Type)
				if _, ok := tpMap[key]; !ok {
					types = append(types, key)
					tpMap[key] = struct{}{}
				}
			} else {
				buf.WriteString(transMarkdownField(item.Type, false))
			}
			buf.WriteString("|")
			buf.WriteString(transMarkdownField(fmt.Sprintf("%v", item.Require), false))
			buf.WriteString("|")
			buf.WriteString(transMarkdownField(item.Default, false))
			buf.WriteString("|")
			buf.WriteString(transMarkdownField(item.Describe, false))
			if len(item.Enums.Names) != 0 {
				if item.Describe != "" {
					buf.WriteString("<br>")
				}
				for idx, nd := range item.Enums.Names {
					if nd[1] != "" {
						buf.WriteString(transMarkdownField(fmt.Sprintf("- `%s`:%s<br>", nd[0], nd[1]), false))
					} else {
						buf.WriteString(transMarkdownField(fmt.Sprintf("- `%s`", nd[0]), false))
					}
					if idx != len(item.Enums.Names)-1 {
						buf.WriteString("<br>")
					}
				}

			}
			buf.WriteString("|\n")
		}
	}

	genEnums := func(enums *EnumInfo, desc string) {
		buf.WriteString(fmt.Sprintf("**Type:** %s\n", enums.Type))
		if len(desc) != 0 {
			buf.WriteString(desc)
			buf.WriteString("\n")
		}

		if len(enums.Names) != 0 {
			buf.WriteString("| Enum Value      | Describe          |\n")
			buf.WriteString("|----------|--------------|\n")
			for _, info := range enums.Names {

				buf.WriteString("|")
				buf.WriteString(info[0])
				buf.WriteString("|")
				buf.WriteString(info[1])
				buf.WriteString("|\n")
			}
		}

	}
	if mk.MainStructName != "" {
		genStruct(data[mk.MainStructName])
		delete(data, mk.MainStructName)
	}

	for idx := 0; idx < len(types); idx++ {
		name := types[idx]
		structInfo, ok := data[name]
		if !ok {
			continue
		}
		modPath, typeName := parseKey(name)
		buf.WriteString(fmt.Sprintf("\n## %s\n", mk.ObjTitleFunc(modPath, typeName)))
		if structInfo.Enums != nil {
			genEnums(structInfo.Enums, structInfo.Describe)
		} else {
			genStruct(structInfo)
		}
	}

	buf.WriteString(fmt.Sprintf("\n---\n"+
		"**%s**\n"+
		"GENERATED BY THE COMMAND [type2md](https://github.com/eleztian/type2md)\n",
		mk.MainStructName))

	return buf.Bytes()
}

var markdownStringReplacer = strings.NewReplacer(
	//"-", "&#45;",
	"!", "&#33;",
	"”", "&#34;",
	"%", "&#37;",
	"&", "&#38;",
	"'", "&#39;",
	"(", "&#40;",
	")", "&#41;",
	"*", "&#42;",
	"+", "&#43;",
	"<", "&#60;",
	"=", "&#61;",
	">", "&#62;",
	"?", "&#63;",
	"@", "&#64;",
	"[", "&#91;",
	"\\", "&#92;",
	"]", "&#93; ",
	"{", "&#123;",
	"|", "&#124;",
	"}", "&#125;",
	"\n", "<br>",
)
var markdownStringReplacerNoNewLine = strings.NewReplacer(
	"-", "&#45;",
	"!", "&#33;",
	"”", "&#34;",
	"%", "&#37;",
	"&", "&#38;",
	"'", "&#39;",
	"(", "&#40;",
	")", "&#41;",
	"*", "&#42;",
	"+", "&#43;",
	"<", "&#60;",
	"=", "&#61;",
	">", "&#62;",
	"?", "&#63;",
	"@", "&#64;",
	"[", "&#91;",
	"\\", "&#92;",
	"]", "&#93; ",
	"{", "&#123;",
	"|", "&#124;",
	"}", "&#125;",
)

func transMarkdownField(src string, allowNewline bool) string {
	if src == "" {
		return " "
	}
	if allowNewline {
		return markdownStringReplacerNoNewLine.Replace(src)
	} else {
		return markdownStringReplacer.Replace(src)
	}
}

func parseKey(name string) (string, string) {
	var (
		modPath  string
		typeName string
	)
	lastIdx := strings.LastIndex(name, ".")
	if lastIdx < 0 {
		typeName = name
	} else {
		typeName = name[lastIdx+1:]
		modPath = name[:lastIdx]
	}

	return modPath, typeName
}

func genKey(modPath, typeName string) string {
	if modPath == "" {
		return typeName
	}

	return modPath + "." + typeName
}
