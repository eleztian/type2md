package main

import (
	"bytes"
	"fmt"
	"strings"
)

type Markdown struct {
	Title          string
	MainStructName string
	Desc           string
	ObjTitleFunc   func(modPath string, typeName string) string
}

func (mk *Markdown) Generate(data map[string]StructInfo) []byte {
	buf := bytes.NewBuffer(nil)

	buf.WriteString("# " + mk.Title + "\n")

	genStruct := func(structInfo StructInfo) {
		buf.WriteString(structInfo.Describe)
		buf.WriteString("\n")

		buf.WriteString(
			"| Key      | Type      | Require | Default           | Describe          |\n" +
				"|----------|----------|-----|------------------|--------------|\n")
		for _, item := range structInfo.Fields {
			buf.WriteString("|")
			buf.WriteString(item.Name)
			buf.WriteString("|")
			if item.Reference != "" {
				buf.WriteString(fmt.Sprintf("[%s](#%s)", item.Type, mk.ObjTitleFunc(item.Reference, item.Type)))
			} else {
				buf.WriteString(item.Type)
			}
			buf.WriteString("|")
			buf.WriteString(fmt.Sprintf("%v", item.Require))
			buf.WriteString("|")
			buf.WriteString(item.Default)
			buf.WriteString("|")
			buf.WriteString(item.Describe)
			if len(item.Enums.Names) != 0 {
				if item.Describe != "" {
					buf.WriteString("<br>")
				}
				for idx, nd := range item.Enums.Names {
					if nd[1] != "" {
						buf.WriteString(fmt.Sprintf("- `%s`:%s<br>", nd[0], nd[1]))
					} else {
						buf.WriteString(fmt.Sprintf("- `%s`", nd[0]))
					}
					if idx != len(item.Enums.Names)-1 {
						buf.WriteString("<br>")
					}
				}

			}
			buf.WriteString("|\n")
		}
	}

	genEnums := func(enums *EnumInfo, desc string) {
		buf.WriteString(fmt.Sprintf("**Type:** %s\n\n", enums.Type))
		buf.WriteString(desc)
		buf.WriteString("\n")

		if len(enums.Names) != 0 {
			buf.WriteString("| Enum Value      | Describe          |\n")
			buf.WriteString("|----------|--------------|\n")
			for _, info := range enums.Names {

				buf.WriteString("|")
				buf.WriteString(info[0])
				buf.WriteString("|")
				buf.WriteString(info[1])
				buf.WriteString("|\n")
			}
		}

	}
	if mk.MainStructName != "" {
		genStruct(data[mk.MainStructName])
		delete(data, mk.MainStructName)
	}

	for name, structInfo := range data {
		var (
			modPath  string
			typeName string
		)
		lastIdx := strings.LastIndex(name, ".")
		if lastIdx < 0 {
			typeName = name
		} else {
			typeName = name[lastIdx+1:]
			modPath = name[:lastIdx]
		}

		if structInfo.Enums != nil {
			buf.WriteString(fmt.Sprintf("\n## %s\n", mk.ObjTitleFunc(modPath, typeName)))
			genEnums(structInfo.Enums, structInfo.Describe)
		} else {
			buf.WriteString(fmt.Sprintf("\n## %s\n", mk.ObjTitleFunc(modPath, typeName)))
			genStruct(structInfo)
		}
	}

	buf.WriteString(fmt.Sprintf("\n\n---\n"+
		"**%s**\n"+
		"GENERATED BY THE COMMAND [type2md](https://github.com/eleztian/type2md)\n\n",
		mk.MainStructName))

	return buf.Bytes()
}
